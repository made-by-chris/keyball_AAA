<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Combo Move Grid Renderer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 100vw;
        }

        .move-container {
            display: inline-block;
            margin: 10px;
            text-align: center;
        }

        canvas {
            border: 1px solid #ccc;
            background: #fff;
        }

        button {
            margin-top: 5px;
            display: block;
        }

        #controls {
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button id="downloadAll">Download All</button>
    </div>
    <div id="moves"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        // Define moves with 4x4 state grids (0=blank,1=rounded square,2=doubletap,3=shift-press)
        const moves = [

            {
                name: 'Raise', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, [0, 1], 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: false, intercardinal: false
            },
            {
                name: 'Strike', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, 2, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: false, intercardinal: false
            },
            {
                name: 'Whack', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, [1, 1], 0, 0],
                    [0, [0, 1], 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: true
            },
            {
                name: 'Stairs', grid: [
                    [0, 0, 0, [2, 1], 0],
                    [0, 0, [1, 1], 0, 0],
                    [0, [0, 1], 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: true
            },
            {
                name: 'Seesaw', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, [2, 1], [0, 1], [1, 1], 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: false, cardinal: true, intercardinal: true
            },
            {
                name: 'Ripple', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [[0, 1], 0, [1, 1], [2, 1], 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: false
            },
            {
                name: 'Wave', grid: [
                    [0, 0, 0, 0, 0],
                    [[0, 1], [1, 1], 0, [2, 1], 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: false
            },
            {
                name: 'Tilt', grid: [
                    [[0, 1], 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [[1, 1], 0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: false
            },
            {
                name: 'Diagonal', grid: [
                    [[0, 1], 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, [1, 1]]
                ], pingPong: true, cardinal: false, intercardinal: false
            },
            {
                name: 'curl', grid: [
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [[0, 1], 0, [2, 1], [1, 1], 0],
                    [0, 0, 0, 0, 0]
                ], pingPong: true, cardinal: true, intercardinal: false
            },
            // bowl, curl, conveyor force, catapult/"lob"
        ];

        const CELL_SIZE = 30;
        const GRID_WIDTH = 5;
        const GRID_HEIGHT = 4;
        const HEADER_HEIGHT = CELL_SIZE; // icon slots same as cell size

        function drawStar(ctx, cx, cy, r, roundness = 0.5) {
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (Math.PI / 2) * i - Math.PI / 4;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevAngle = (Math.PI / 2) * (i - 1) - Math.PI / 4;
                    const prevX = cx + Math.cos(prevAngle) * r;
                    const prevY = cy + Math.sin(prevAngle) * r;
                    const midX = (prevX + x) / 2;
                    const midY = (prevY + y) / 2;
                    ctx.quadraticCurveTo(midX, midY, x, y);
                }
            }
            const firstAngle = -Math.PI / 4;
            const firstX = cx + Math.cos(firstAngle) * r;
            const firstY = cy + Math.sin(firstAngle) * r;
            const lastAngle = (Math.PI / 2) * 3 - Math.PI / 4;
            const lastX = cx + Math.cos(lastAngle) * r;
            const lastY = cy + Math.sin(lastAngle) * r;
            const midX = (lastX + firstX) / 2;
            const midY = (lastY + firstY) / 2;
            ctx.quadraticCurveTo(midX, midY, firstX, firstY);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawHeaderIcons(ctx, move) {
            // Draw icons in slots aligned left, each slot is CELL_SIZE wide
            const iconY = HEADER_HEIGHT / 2;
            let iconIndex = 0;
            ctx.save();
            ctx.lineWidth = 2.5;
            // pingPong: left arrow
            if (move.pingPong) {
                const slotX = iconIndex * CELL_SIZE + CELL_SIZE / 2;
                ctx.strokeStyle = '#0074D9';
                ctx.beginPath();
                ctx.moveTo(slotX - 12, iconY);
                ctx.lineTo(slotX + 8, iconY);
                ctx.moveTo(slotX - 4, iconY - 8);
                ctx.lineTo(slotX - 12, iconY);
                ctx.lineTo(slotX - 4, iconY + 8);
                ctx.stroke();
                iconIndex++;
            }
            // cardinal: cross
            if (move.cardinal) {
                const slotX = iconIndex * CELL_SIZE + CELL_SIZE / 2;
                ctx.strokeStyle = '#2ECC40';
                ctx.beginPath();
                ctx.moveTo(slotX, iconY - 10);
                ctx.lineTo(slotX, iconY + 10);
                ctx.moveTo(slotX - 10, iconY);
                ctx.lineTo(slotX + 10, iconY);
                ctx.stroke();
                iconIndex++;
            }
            // intercardinal: X
            if (move.intercardinal) {
                const slotX = iconIndex * CELL_SIZE + CELL_SIZE / 2;
                ctx.strokeStyle = '#FF4136';
                ctx.beginPath();
                ctx.moveTo(slotX - 8, iconY - 8);
                ctx.lineTo(slotX + 8, iconY + 8);
                ctx.moveTo(slotX + 8, iconY - 8);
                ctx.lineTo(slotX - 8, iconY + 8);
                ctx.stroke();
                iconIndex++;
            }
            ctx.restore();
        }

        function drawCell(ctx, row, col, state, opacity = 1) {
            const x = col * CELL_SIZE;
            const y = row * CELL_SIZE + HEADER_HEIGHT; // shift down for header
            ctx.save();
            ctx.globalAlpha = opacity;
            let value = state;
            if (Array.isArray(state)) value = state[1];
            switch (value) {
                case 1: // rounded 4-pointed star
                    ctx.fillStyle = '#000';
                    drawStar(ctx, x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE * 0.35, 0.5);
                    break;
                case 2: // two smaller stars diagonally in the center
                    ctx.fillStyle = '#000';
                    drawStar(ctx, x + CELL_SIZE / 2 - CELL_SIZE * 0.15, y + CELL_SIZE / 2 - CELL_SIZE * 0.15, CELL_SIZE * 0.18, 0.5);
                    drawStar(ctx, x + CELL_SIZE / 2 + CELL_SIZE * 0.15, y + CELL_SIZE / 2 + CELL_SIZE * 0.15, CELL_SIZE * 0.18, 0.5);
                    break;
                case 3: // shift-press (up arrow)
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    const midX = x + CELL_SIZE / 2;
                    const topY = y + 10;
                    ctx.moveTo(midX, topY);
                    ctx.lineTo(midX + 10, y + CELL_SIZE - 10);
                    ctx.lineTo(midX + 3, y + CELL_SIZE - 10);
                    ctx.lineTo(midX + 3, y + CELL_SIZE - 30);
                    ctx.lineTo(midX - 3, y + CELL_SIZE - 30);
                    ctx.lineTo(midX - 3, y + CELL_SIZE - 10);
                    ctx.lineTo(midX - 10, y + CELL_SIZE - 10);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default:
                    // blank
                    break;
            }
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#ccc';
            ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
            ctx.restore();
        }

        function renderMoves() {
            const container = document.getElementById('moves');
            container.innerHTML = '';
            moves.forEach((move, idx) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'move-container';
                const canvas = document.createElement('canvas');
                canvas.width = CELL_SIZE * GRID_WIDTH;
                canvas.height = CELL_SIZE * GRID_HEIGHT + HEADER_HEIGHT;
                canvas.id = `canvas-${idx}`;
                const ctx = canvas.getContext('2d');
                // Animation state
                let tIndexMap = [];
                let maxTIndex = -1;
                move.grid.forEach((row, r) => {
                    tIndexMap[r] = [];
                    row.forEach((cell, c) => {
                        let t = 0;
                        if (Array.isArray(cell)) t = cell[0];
                        if (t > maxTIndex) maxTIndex = t;
                        tIndexMap[r][c] = t;
                    });
                });
                let currentT = 0;
                let fade = 0;
                const FADE_DURATION = 400; // ms
                let fadingOut = false;
                let fadeOut = 1;
                let direction = 1; // 1 for forward, -1 for backward
                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // Draw header icons
                    drawHeaderIcons(ctx, move);
                    if (fadingOut) {
                        // Fade out all cells
                        move.grid.forEach((row, r) => {
                            row.forEach((cell, c) => {
                                let t = 0;
                                if (Array.isArray(cell)) t = cell[0];
                                if (t <= maxTIndex) {
                                    drawCell(ctx, r, c, cell, fadeOut);
                                }
                            });
                        });
                        fadeOut -= 16 / FADE_DURATION;
                        if (fadeOut > 0) {
                            requestAnimationFrame(animate);
                        } else {
                            // After fade out, reset and restart
                            fadingOut = false;
                            fadeOut = 1;
                            if (move.pingPong) {
                                direction *= -1; // Reverse direction
                                if (direction === 1) {
                                    currentT = 0;
                                } else {
                                    currentT = maxTIndex;
                                }
                            } else {
                                direction = 1;
                                currentT = 0;
                            }
                            fade = 0;
                            setTimeout(() => {
                                requestAnimationFrame(animate);
                            }, 500);
                        }
                        return;
                    }
                    let animating = false;
                    move.grid.forEach((row, r) => {
                        row.forEach((cell, c) => {
                            let t = 0, value = cell;
                            if (Array.isArray(cell)) {
                                t = cell[0];
                                value = cell[1];
                            }
                            if ((direction === 1 && t < currentT) || (direction === -1 && t > currentT)) {
                                drawCell(ctx, r, c, cell, 1);
                            } else if (t === currentT) {
                                animating = true;
                                drawCell(ctx, r, c, cell, fade);
                            }
                        });
                    });
                    if (animating) {
                        fade += 16 / FADE_DURATION;
                        if (fade < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            fade = 1;
                            moveNext();
                        }
                    }
                }
                function moveNext() {
                    fade = 0;
                    if (move.pingPong) {
                        currentT += direction;
                        if ((direction === 1 && currentT <= maxTIndex) || (direction === -1 && currentT >= 0)) {
                            requestAnimationFrame(animate);
                        } else {
                            // Start fade out phase
                            fadingOut = true;
                            fadeOut = 1;
                            setTimeout(() => {
                                requestAnimationFrame(animate);
                            }, 2000);
                        }
                    } else {
                        currentT++;
                        if (currentT <= maxTIndex) {
                            requestAnimationFrame(animate);
                        } else {
                            // Start fade out phase
                            fadingOut = true;
                            fadeOut = 1;
                            setTimeout(() => {
                                requestAnimationFrame(animate);
                            }, 2000);
                        }
                    }
                }
                // Start animation
                requestAnimationFrame(animate);
                const label = document.createElement('div');
                label.textContent = move.name;
                const btn = document.createElement('button');
                btn.textContent = 'Download';
                btn.onclick = () => downloadCanvas(canvas, `${move.name}.png`);
                wrapper.appendChild(label);
                wrapper.appendChild(canvas);
                wrapper.appendChild(btn);
                container.appendChild(wrapper);
            });
        }

        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        document.getElementById('downloadAll').addEventListener('click', () => {
            const zip = new JSZip();
            moves.forEach((move, idx) => {
                const canvas = document.getElementById(`canvas-${idx}`);
                const dataURL = canvas.toDataURL('image/png');
                const imgData = dataURL.split(',')[1];
                zip.file(`${move.name}.png`, imgData, { base64: true });
            });
            zip.generateAsync({ type: 'blob' }).then(content => {
                const link = document.createElement('a');
                link.download = 'all_moves.zip';
                link.href = URL.createObjectURL(content);
                link.click();
            });
        });

        // Initialize
        renderMoves();
    </script>
</body>

</html>